# posterior ∝ prior * likelihood
fx <- function(x){do.call(fun_prior_b[v],
as.list(args_b[[v]])) *
dnorm(x, mean = l_mu, sd = 1/sqrt(l_tau))}
# calculate the maximum of this function to serve as mean of proposal
propmean <- optimize(f = fx, maximum = T, lower = min(beta[,v])-100,
upper = max(beta[,v])+100)$maximum
#qx <- function(x) beta[i,v]+dnorm(x, 0, tune)
# Sample candidate value from OLS proposal distribution
bstar <- beta[i,v]+rnorm(1, 0, tune)
# Compute the acceptance ratio
#r <- min(1, fx(bstar)/fx(beta[i,v])*qx(beta[i,v])/qx(bstar))
r <- min(1,fx(bstar)/fx(beta[i,v]))
# Assign when accepted
if (runif(1) <= r){
beta[i+1,v] <- bstar
} else {
beta[i+1,v] <- beta[i,v]
}
# Dynamic tuning procedure using information from
# https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default
# /viewer.htm#statug_mcmc_sect022.htm
# Start dynamic tuning after 10 iterations
if (dtuning == T && i > 10){
# Set the optimal acceptance rate
popt <- 0.45
# Calculate current acceptance rate
pcur <- mean(beta[1:i,v]==beta[2:(i+1),v])
# If acceptance rate is too high, adjust scale parameter to be more
# wide. This will decrease the acceptance rate. If the acceptance rate
# is too low, adjust the scale parameter downwards.
if (pcur > 0.5 || pcur < 0.15){
tune <- (tune*(1/pnorm(popt/2)))/(1/pnorm(pcur/2))
}
}
}
}
# Calculate Rsquared
# Residual Variance
varres <- var(y-X%*%beta[i,])
rsq[i+1] <- 1-varres/var(y)
}
result <- as.data.frame(cbind(var,beta,rsq))
colnames(result) <- c("Variance",paste("b", rep(0:(k-1)), sep = ""),
"Rsquared")
return(result)
}
s <- rmhs(iter = 9999, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
mean(s$b1[-length(s$b1)]==s$b1[-1])
plot(s$b1,type = "l")
require(rbenchmark)
dt <- function(){
dtd <- rmhs(iter = 99999, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
}
ndt <- function(){
ndtd <- rmhs(iter = 99999, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
}
benchmark(dt,ndt,1)
benchmark(dt,ndt,replications=1)
benchmark(dt(),ndt(),replications=1)
dt <- function(){
dtd <- rmhs(iter = 9999, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
}
ndt <- function(){
ndtd <- rmhs(iter = 9999, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = F, verbose = T)
}
benchmark(dt(),ndt(),replications=1)
ndt <- function(){
ndtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = F, verbose = T)
}
dtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
dt <- function(){
dtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
}
mean(dtd$b1[-length(dtd$b1)]==dtd$b1[-1])
dt <- function(){
dtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
}
benchmark(dt(),ndt(),replications=0)
benchmark(dtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T),
ndtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = F, verbose = T),replications=0)
10%10
10%%10
0%%10
1%%10
rmhs <- function(iter = 999, y, X, prior_a, prior_b, fun_prior_b, args_b,
inits = NULL, dtuning = F, verbose = T){
# Sample size and number of regressors
n <- length(y)
k <- ncol(X)
# Monitor parameters
var <- numeric(iter+1)
beta <- matrix(numeric(k*(iter+1)), ncol = k)
rsq <- c(numeric(iter+1))
tune <- rep(2.38,k)
# Set initial values
if (is.null(inits) || length(inits) != k + 1 || !is.numeric(unlist(inits))
|| is.null(inits$var)){
# Calculate initial values if inits have been incorrectly specified
# or not specified at all.
if (verbose == T) {cat("Beta inits assumed ols estimates, variance 1. \n")}
var[1] <- 1
beta[1,] <- solve(t(X)%*%X)%*%t(X)%*%y
} else {
# If inits have been correctly specified, use them.
if (verbose == T) {
cat("Inits:", paste(names(unlist(inits)),unlist(inits)),"\n")
}
var[1] <- inits$var # assign var init to var
beta[1,] <- unlist(inits[- which(names(inits) == "var")]) # assign remaining
# ordered to beta
}
# Start the MCMC procedure
for (i in 1:iter){
# sample conditional posterior for variance
# Posterior alpha
p_a <- prior_a + n/2
# Posterior residuals
p_res <- y - (X %*% beta[i,])
# Posterior beta
p_b <- prior_b + (t(p_res)%*%p_res)/2
# Sample
var[i+1] <- 1/rgamma(1, shape = p_a, rate = p_b)
# sample conditional posterior for b's using MH OR Gibbs procedure
for (v in 1:k){
if (fun_prior_b[v] == "dnorm"){
# Gibbs procedure if prior is conjugate
# Posterior Variance
p_tau <- args_b[[v]][2] + var[i+1]/t(X[,v])%*%X[,v]
# Posterior Mean
p_mu <- (args_b[[v]][1]/args_b[[v]][2] +
(y-beta[i,-v]%*%t(X[,-v]))%*%X[,v]/var[i+1]) * p_tau
# Sample conditional posterior for beta[v]
beta[i+1,v] <- rnorm(1, mean = p_mu, sd = 1/sqrt(p_tau))
} else {
# Random Walk MH procedure if this is not the case
# pdf for the target distribution
# Likelihood Variance
l_tau <- var[i+1]/t(X[,v])%*%X[,v]
# Likelihood Mean
l_mu <- (y-beta[i,-v]%*%t(X[,-v]))%*%X[,v]/var[i+1] * l_tau
# posterior ∝ prior * likelihood
fx <- function(x){do.call(fun_prior_b[v],
as.list(args_b[[v]])) *
dnorm(x, mean = l_mu, sd = 1/sqrt(l_tau))}
# calculate the maximum of this function to serve as mean of proposal
propmean <- optimize(f = fx, maximum = T, lower = min(beta[,v])-100,
upper = max(beta[,v])+100)$maximum
#qx <- function(x) beta[i,v]+dnorm(x, 0, tune)
# Sample candidate value from OLS proposal distribution
bstar <- beta[i,v]+rnorm(1, 0, tune[v])
# Compute the acceptance ratio
#r <- min(1, fx(bstar)/fx(beta[i,v])*qx(beta[i,v])/qx(bstar))
r <- min(1,fx(bstar)/fx(beta[i,v]))
# Assign when accepted
if (runif(1) <= r){
beta[i+1,v] <- bstar
} else {
beta[i+1,v] <- beta[i,v]
}
# Dynamic tuning procedure using information from
# https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default
# /viewer.htm#statug_mcmc_sect022.htm
# Dynamic tuning after every 10th iteration
if (dtuning == T && i%%10 == 0){
# Set the optimal acceptance rate
popt <- 0.45
# Calculate current acceptance rate
pcur <- mean(beta[1:i,v]==beta[2:(i+1),v])
# If acceptance rate is too high, adjust scale parameter to be more
# wide. This will decrease the acceptance rate. If the acceptance rate
# is too low, adjust the scale parameter downwards.
if (pcur > 0.5 || pcur < 0.15){
tune[v] <- (tune[v]*(1/pnorm(popt/2)))/(1/pnorm(pcur/2))
}
}
}
}
# Calculate Rsquared
# Residual Variance
varres <- var(y-X%*%beta[i,])
rsq[i+1] <- 1-varres/var(y)
}
result <- as.data.frame(cbind(var,beta,rsq))
colnames(result) <- c("Variance",paste("b", rep(0:(k-1)), sep = ""),
"Rsquared")
return(result)
}
dtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
mean(dtd$b1[-length(dtd$b1)]==dtd$b1[-1])
plot(dtd$b1,type = "l")
plot(dtd$b1[-(1:50)],type = "l")
plot(dtd$b1[-(1:100)],type = "l")
plot(dtd$b1[-(1:1000)],type = "l")
plot(dtd$b1[-(1:5000)],type = "l")
plot(dtd$b1[-(1:20000)],type = "l")
plot(dtd$b1,type = "l", log = "x")
plot(dtd$b1,type = "l", log = "y")
plot(dtd$b1,type = "l")
colMeans(dtd$b1)
colMeans(dtd)
mean(dtd$b1[-length(dtd$b1)]==dtd$b1[-1])
mean(dtd$b1[-(40:length(dtd$b1))]==dtd$b1[2:41])
mean(dtd$b1[-(40:length(dtd$b1))]==dtd$b1[2:4])
mean(dtd$b1[-(40:length(dtd$b1))]==dtd$b1[2:40])
t <- numeric(length(dtd$b1))
for (i in 10:length(dtd$b1))  t[i] <- mean(dtd$b1[-(i:length(dtd$b1))]==dtd$b1[2:i])
plot(t[-(1:10)], type= "l")
plot(t[-(1:10)], type= "l", main = "Acceptance Rate MCMC", ylab = "Acceptance Rate", xlab = "MCMC Step")
plot(density(dtd$b1))
plot(density(dtd$b0))
plot(dtd$b0)
plot(dtd$b1)
plot(dtd$b1[-(1:10000)])
plot(dtd$b1[-(1:20000)])
plot(dtd$b1[-(1:30000)])
plot(dtd$b1[-(1:40000)])
ndtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = F, verbose = T)
nt <- numeric(length(ndtd$b1))
for (i in 10:length(ndtd$b1))  nt[i] <- mean(ndtd$b1[-(i:length(ndtd$b1))]==ndtd$b1[2:i])
plot(nt[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "red")
plot(t[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "blue")
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "red")
plot(nt[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "red")
colMeans(ndtd)
colMeans(ndtd[-(1:5000)])
colMeans(ndtd[-(1:5000),])
colMeans(ndtd[-(1:7000),])
colMeans(ndtd[-(1:10000),])
colMeans(ndtd[-(1:25000),])
plot(ndtd$b1, type = "l")
rmhs <- function(iter = 999, y, X, prior_a, prior_b, fun_prior_b, args_b,
inits = NULL, dtuning = F, verbose = T){
# Sample size and number of regressors
n <- length(y)
k <- ncol(X)
# Monitor parameters
var <- numeric(iter+1)
beta <- matrix(numeric(k*(iter+1)), ncol = k)
rsq <- c(numeric(iter+1))
# Set scale parameter of proposal distribution of each predictor to 2.38
tune <- rep(2.38,k)
# Set initial values
if (is.null(inits) || length(inits) != k + 1 || !is.numeric(unlist(inits))
|| is.null(inits$var)){
# Calculate initial values if inits have been incorrectly specified
# or not specified at all.
if (verbose == T) {cat("Beta inits assumed ols estimates, variance 1. \n")}
var[1] <- 1
beta[1,] <- solve(t(X)%*%X)%*%t(X)%*%y
} else {
# If inits have been correctly specified, use them.
if (verbose == T) {
cat("Inits:", paste(names(unlist(inits)),unlist(inits)),"\n")
}
var[1] <- inits$var # assign var init to var
beta[1,] <- unlist(inits[- which(names(inits) == "var")]) # assign remaining
# ordered to beta
}
# Start the MCMC procedure
for (i in 1:iter){
# sample conditional posterior for variance
# Posterior alpha
p_a <- prior_a + n/2
# Posterior residuals
p_res <- y - (X %*% beta[i,])
# Posterior beta
p_b <- prior_b + (t(p_res)%*%p_res)/2
# Sample
var[i+1] <- 1/rgamma(1, shape = p_a, rate = p_b)
# sample conditional posterior for b's using MH OR Gibbs procedure
for (v in 1:k){
if (fun_prior_b[v] == "dnorm"){
# Gibbs procedure if prior is conjugate
# Posterior Variance
p_tau <- args_b[[v]][2] + var[i+1]/t(X[,v])%*%X[,v]
# Posterior Mean
p_mu <- (args_b[[v]][1]/args_b[[v]][2] +
(y-beta[i,-v]%*%t(X[,-v]))%*%X[,v]/var[i+1]) * p_tau
# Sample conditional posterior for beta[v]
beta[i+1,v] <- rnorm(1, mean = p_mu, sd = 1/sqrt(p_tau))
} else {
# Random Walk MH procedure if this is not the case
# pdf for the target distribution
# Likelihood Variance
l_tau <- var[i+1]/t(X[,v])%*%X[,v]
# Likelihood Mean
l_mu <- (y-beta[i,-v]%*%t(X[,-v]))%*%X[,v]/var[i+1] * l_tau
# posterior ∝ prior * likelihood
fx <- function(x){do.call(fun_prior_b[v],
as.list(args_b[[v]])) *
dnorm(x, mean = l_mu, sd = 1/sqrt(l_tau))}
# calculate the maximum of this function to serve as mean of proposal
propmean <- optimize(f = fx, maximum = T, lower = min(beta[,v])-100,
upper = max(beta[,v])+100)$maximum
#qx <- function(x) beta[i,v]+dnorm(x, 0, tune)
# Sample candidate value from OLS proposal distribution
bstar <- beta[i,v]+rnorm(1, 0, tune[v])
# Compute the acceptance ratio
#r <- min(1, fx(bstar)/fx(beta[i,v])*qx(beta[i,v])/qx(bstar))
r <- min(1,fx(bstar)/fx(beta[i,v]))
# Assign when accepted
if (runif(1) <= r){
beta[i+1,v] <- bstar
} else {
beta[i+1,v] <- beta[i,v]
}
# Dynamic tuning procedure using information from
# https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default
# /viewer.htm#statug_mcmc_sect022.htm
# Dynamic tuning after every 500th iteration
if (dtuning == T && i%%500 == 0){
# Set the optimal acceptance rate
popt <- 0.45
# Calculate current acceptance rate
pcur <- mean(beta[1:i,v]==beta[2:(i+1),v])
# If acceptance rate is too high, adjust scale parameter to be more
# wide. This will decrease the acceptance rate. If the acceptance rate
# is too low, adjust the scale parameter downwards.
if (pcur > 0.5 || pcur < 0.15){
tune[v] <- (tune[v]*(1/pnorm(popt/2)))/(1/pnorm(pcur/2))
}
}
}
}
# Calculate Rsquared
# Residual Variance
varres <- var(y-X%*%beta[i,])
rsq[i+1] <- 1-varres/var(y)
}
result <- as.data.frame(cbind(var,beta,rsq))
colnames(result) <- c("Variance",paste("b", rep(0:(k-1)), sep = ""),
"Rsquared")
return(result)
}
dtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(1,1)),
inits = NULL, dtuning = T, verbose = T)
t <- numeric(length(dtd$b1))
for (i in 10:length(dtd$b1))  t[i] <- mean(dtd$b1[-(i:length(dtd$b1))]==dtd$b1[2:i])
plot(t[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "blue")
mean(ndtd$b1[-length(ndtd$b1)]==ndtd$b1[-1])
mean(dtd$b1[-length(dtd$b1)]==dtd$b1[-1])
par(new = T)
plot(nt[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "red")
plot(t[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "blue")
plot(t[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "blue", ylim = c(0,0.3))
par(new = T)
plot(nt[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "red", ylim = c(0,0.3))
plot(t[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "blue", ylim = c(0.1,0.3))
par(new = T)
plot(nt[-(1:10)], type= "l", main = "Acceptance Rate MCMC",
ylab = "Acceptance Rate", xlab = "MCMC Step", col = "red", ylim = c(0.1,0.3))
colMeans(dtd[-(1:1000),])
colMeans(ndtd[-(1:1000),])
plot(density(dtd$b1), type = "l")
plot(density(ndtd$b1), type = "l")
dbinom(3,30,0.091)
dbinom(6,30,0.091)
curve(dbinom(x,30,0.091))
curve(dbinom(x,30,0.091), xlim = c(0,30))
plot(dbinom(x,30,0.091), xlim = c(0,30))
for (i in 1:30) dbinom(i,30,0.091)
for (i in 1:30) x[i] <- dbinom(i,30,0.091)
x<- 0
for (i in 1:30) x[i] <- dbinom(i,30,0.091)
plot(x)
y <- 0
for (i in 1:30) y[i] <- dbinom(i,30,0.2)
par(new = T)
plot(y, col = red)
plot(y, col = "red")
plot(x, type = "l")
plot(y, col = "red", type = "l")
par(new = T)
plot(x, type = "l")
plot(y, col = "red", type = "l", xlim = c(0,15))
plot(y, col = "red", type = "l", xlim = c(1),15))
plot(y, col = "red", type = "l", xlim = c(1,15))
par(new = T)
plot(x, type = "l", col = "blue", xlim = c(1,15))
plot(y, col = "red", type = "l", xlim = c(1,15), ylim = c(0,0.2))
par(new = T)
plot(x, type = "l", col = "blue", xlim = c(1,15), ylim = c(0,0.2))
plot(y, col = "red", type = "l", xlim = c(1,15), ylim = c(0,0.3))
par(new = T)
plot(x, type = "l", col = "blue", xlim = c(1,15), ylim = c(0,0.3))
plotrej(example1h0, title = "Type-I Error") # Type-1 error
dtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dgamma"),
args_b = list(c(0,0.0001),c(0.01,0.01)),
inits = NULL, dtuning = T, verbose = T)
mean(dtd$b1[-length(dtd$b1)]==dtd$b1[-1])
colMeans(dtd)
lm(dist~speed, data=cars)
colMeans(dtd[-1:500,])
colMeans(dtd[-(1:500),])
dt(20)
?t
?dt
dt(1,20)
dt(1,20,0)
dt(x = 1, df = 20, ncp = 0)
rt(1)
rt(1,20)
dtd <- rmhs(iter = 50000, y = cars$dist, X = cbind(rep(1,50), cars$speed),
prior_a = 0.01, prior_b = 0.01,
fun_prior_b = c("dnorm", "dt"),
args_b = list(c(0,0.0001),c(0.01,0.01)),
inits = NULL, dtuning = T, verbose = T)
require(stats)
dt(1,20)
rm(list = ls())
save.image("~/.RData")
source('~/1 - Studie/3 - UU/Semester 2/Bayesian Statistics/Assignment_2/blim/evaluate.r')
source('~/1 - Studie/3 - UU/Semester 2/Bayesian Statistics/Assignment_2/blim/blim.r')
source('~/1 - Studie/3 - UU/Semester 2/Bayesian Statistics/Assignment_2/blim/samplers.r')
setwd("~/1 - Studie/3 - UU/Semester 2/Bayesian Statistics/Assignment_2/blim")
source('~/1 - Studie/3 - UU/Semester 2/Bayesian Statistics/Assignment_2/blim/samplers.r')
fit <- blim(dist~speed, data=cars)
summary(fit)
RcppArmadillo::RcppArmadillo.package.skeleton("blim", path = "C:/Users/Erik-Jan/Documents/3 - Personal/R")
setwd(C:/Users/Erik-Jan/Documents/3 - Personal/R/blim")
setwd("C:/Users/Erik-Jan/Documents/3 - Personal/R/blim")
Rcpp::compileAttributes()
cmd build C:/Users/Erik-Jan/Documents/3 - Personal/R/
cmd build C:/Users/Erik-Jan/Documents/3 - Personal/R/blim
R cmd build C:/Users/Erik-Jan/Documents/3 - Personal/R/blim
library(blim)
rm(list = ls)()
rm(list = ls())
?blim
library(blim)
?blim
library(blim)
?blim
library(blim)
?blim
fit <- blim(dist~speed, data=cars)
summary(fit)
library(blim)
?blim
library(blim)
require(devtools)
install_github("blim", username = "vankesteren")
install_github("vankesteren/blim")
require(blim)
?blim
