"dcauchy(0,0.7071068)", "dcauchy(0,0.7071068)"),
method = "rmhs", dtuning = T)
# check convergence and autocorr
cplots(m3)
aplots(m3)
# model selection
BF(m1, m2, bootstrap = T, plot = T)
BF(m2, m3, bootstrap = T, plot = T)
BF(m1, m3, bootstrap = T, plot = T)
aplots(catrmhs)
aplots(m3)
plot(m3$auto)
BF(m1, m2)
BF(m2, m3)
BF(m1, m3)
BF(m3, m1)
BF(m3, m2)
DIC(m1)
DIC(m2)
DIC(m3)
cplots(m1)
plot(m2$auto)
par(mfrow = c(1,1), mar = margins)
par(mar=c(5.1,4.1,4.1,2.1)
mfrow = c(1,1))
par(mar=c(5.1,4.1,4.1,2.1), mfrow = c(1,1)
)
plot(m1$auto)
cplots(m1)
plot(m1$auto)
aplots(m1)
plot(m1$auto)
aplots(m2)
aplots(m3)
# let's make model 1 without covariates and look at burnin. Use exact same
# method as we will use later for optimal comparison
m1 <- blim(bwt~smoke+ht+ui, birthwt, iter = 99999,
prior_b = c("dnorm(2946.89039039039,388400.532757457)",
"dnorm(2946.89039039039,388400.532757457)",
"dnorm(2946.89039039039,388400.532757457)"),
method = "rmhs", dtuning = T)
cplots(m1)
m1 <- blim(bwt~smoke+ht+ui, birthwt, iter = 99999,
prior_b = c("dnorm(2946.89039039039,388400.532757457)",
"dnorm(0,3000)","dnorm(0,3000)","dnorm(0,3000)"),
method = "rmhs", dtuning = T)
cplots(m1)
plot(m2$auto)
aplots(m1)
ICBF(m1, model = "par[2] < par[4] < par[3]")
ICBF(m1, model = "par[2] < par[4] $$ par[4] < par[3]")
ICBF(m1, model = "par[2] < par[4] && par[4] < par[3]")
ICBF(m1, model = "par[2] < par[4] && par[3] < par[2]")
ICBF(m1, model = "par[2] > par[4] && par[3] < par[2]")
ICBF(m1, model = "par[2] > par[3] && par[3] > par[4]")
?subset
subset(airquality, Temp > 80, select = c(Ozone, Temp))
?GDP
??GDP
datasheet <- UN
require(car)
datasheet <- UN
subset(datasheet,GDP>5000)
subset(datasheet,subset = GDP>5000)
subset(datasheet,subset = GDP > 5000)
subset(datasheet, gdp > 5000)
rm(datasheet)
BF(m1, m2)
BF(m2, m3)
hoi <- function(x,y,z)match.call()
hoi(m1,m3, m2)
hoi <- function(x,y,z)match.arg()
hoi(m1,m3, m2)
hoi <- function(x,y,z)match.arg(arg = c(x))
hoi(m1,m3, m2)
hoi <- function(x,y,z)match.arg(arg = "x")
hoi(m1,m3, m2)
hoi <- function(x,y,z)sys.call()
hoi(m1,m3, m2)
hoi <- function(x,y,z)as.list(sys.call())
hoi(m1,m3, m2)
hoi <- function(x,y,z)paste("Bayes Factor",as.list(sys.call())[[2]],"/",as.list(sys.call())[[3]],sep = "")
hoi(m1,m3, m2)
hoi <- function(x,y,z)paste("Bayes Factor ",as.list(sys.call())[[2]],"/",as.list(sys.call())[[3]],sep = "")
hoi(m1,m3, m2)
BF <- function(blimfit1, blimfit2, bootstrap = F, plot = F){
# Function to calculate the Bayes Factor of two (nested) models
# Not much more than a wrapper around the lmml function!
# use bootstrap to see if you need more iterations for accurate estimation
# of the bayes factor
# Check if object has class blimfit
if (class(blimfit1) != "blimfit" ||
class(blimfit2) != "blimfit") stop("Please enter a blimfit object!")
if (bootstrap == F){
# Calculate bayes factor. remember: lmml returns log marginal likelihood!
BF <- exp(lmml(blimfit1)-lmml(blimfit2))
names(BF) <- paste("Bayes Factor ",
as.list(sys.call())[[2]],"/",
as.list(sys.call())[[3]],sep = "")
} else {
cat("Warning! Bootstrap Bayes Factor can take a while. \n")
# Initialise output vector
BFs <- numeric(1000)
# Start bootstrap procedure
for (i in 1:1000){
h1 <- blimfit1
h1$trace <- h1$trace[sample(nrow(h1$trace),replace = T),]
h2 <- blimfit2
h2$trace <- h2$trace[sample(nrow(h2$trace),replace = T),]
BFs[i]<-exp(lmml(h1)-lmml(h2))
}
# Output estimate and 95% interval
BF <- c(mean(BFs),quantile(BFs, probs = c(0.025, 0.975)))
names(BF)[1] <- paste("BayesFactor ",
as.list(sys.call())[[2]],"/",
as.list(sys.call())[[3]],sep = "")
# Plot the bootstrap distribution
if (plot == T){
hist(BFs, breaks = "FD", col = "light green", border = "light green",
main = "Bootstrap Distribution of Bayes Factor",
xlab = "Bayes Factor")
}
}
return(BF)
}
BF(m1,m3)
BF(m1,m3)
BF(m1,m2)
BF(m3,m2)
BF(m3,m3)
BF(m2,m3)
BF(m3,m1)
BF(m1)
BF(m1,m1)
BF(m1,m2)
BF(m1,m3)
summary(m3)
summary(m1)
ICBF(m1, model = "par[2] > par[3] && par[3] > par[4]")
curve(dnorm(x), xlim = c(-3,3))
par(mfrow = c(1,1))
curve(dnorm(x), xlim = c(-3,3))
abline(v=1.96)
abline(i.96-0.5)
abline(v=i.96-0.5)
abline(v= (i.96-0.5))
abline(v= (1.96-0.5))
abline(v= -(1.96-0.5))
plot(dbinom(1:27,1,prob = 0.144), type = "l", xlim = c(0,10))
plot(dbinom(1:27,1,prob = 0.0576), type = "l", xlim = c(0,10))
plot(dbinom(1:27,1,prob = 0.144), type = "l", xlim = c(0,10))
plot(dbinom(1:27,1,prob = 0.0576), type = "l", xlim = c(0,10), ylim = c(0,1))
plot(dbinom(1:27,1,prob = 0.144), type = "l", xlim = c(0,10), ylim = c(0,1))
plot(dbinom(0:27,1,prob = 0.144), type = "l", xlim = c(0,10), ylim = c(0,1))
par(new = T)
plot(dbinom(0:27,1,prob = 0.0576), type = "l", xlim = c(0,10), ylim = c(0,1))
?blim
library(blim)
fit <- blim(dist~speed, cars)
cplots(fit)
ICBF(fit, "par[1] < 0")
ICBF(fit, "par[1] < 0", T)
cplots(m1)
cplots(m2)
cplots(m3)
BF(m2,m3,bootstrap = T,plot = T)
m2 <- blim(bwt~smoke+ht+ui+age, birthwt)
m2 <- blim(bwt~smoke+ht+ui+age, data = birthwt)
library(MASS)
m2 <- blim(bwt~smoke+ht+ui+age, data = birthwt)
m1 <- blim(bwt~smoke+ht+ui, data = birthwt)
BF(m1,m2, bootstrap = T, plot = T)
m3 <- blim(bwt~smoke+ht+ui+lwt, data = birthwt)
BF(m1,m3, bootstrap = T, plot = T)
m3 <- blim(bwt~smoke+ht+ui+lwt, data = birthwt, iter = 99999)
m2 <- blim(bwt~smoke+ht+ui, data = birthwt, iter = 99999)
m1 <- blim(bwt~smoke+ht+ui, data = birthwt, iter = 99999)
BF(m1,m3, bootstrap = T, plot = T)
rm(list = ls())
setwd("~/1 - Studie/3 - UU/Semester 2/Bayesian Statistics/Assignment_2/handin")
library(devtools) # Required for installation
install_github("vankesteren/blim") # Install my package from github
library(blim) # Load this package
example("blim")
BF(fit1,fit2)
library(devtools) # Required for installation
install_github("vankesteren/blim") # Install my package from github
library(blim) # Load this package
BF(fit1,fit2)
BF(fit2,fit1)
BF(fit2,fit1, bootstrap = T, plot = T)
type = c("DW", "lin")
upper(type)
toupper(type)
any(toupper(type)) == "DW"
any(type) == "DW"
type == "DW"
any(type == "DW")
any(toupper(type) == "DW")
any(toupper(type) == "LIN")
tdat <- rnorm(184)
ks.test(tdat)
ks.test(tdat, pnorm)
ks.test(tdat, pnorm)$D
test <- ks.test(tdat, pnorm)
test$statistic
tdat2 <- runif(184,-2,2)
ks.test(tdat2, pnorm)$statistic
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
trace <- fit2$trace[sample(1000),]
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
blimfit <- fit2
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n")
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n")
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
repD
length(repD)
ncol(repD)
nrow(repD)
out <- list()
length(out)
PPPDW <- 0.00123144
if (any(toupper(type)=="DW")) out$DW <- PPPDW
out
PPC <- function(blimfit, fast = TRUE, type = "DW"){
# Check if object has class blimfit
if (class(blimfit) != "blimfit") stop("Please enter a blimfit object!")
# Remove unnecessary information from the posterior distributions (the
# R-squared column)
if (fast == F){
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n")
} else {
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n")
}
# Calculate the observed discrepancy measure for each column of the trace
obsD <- apply(trace[,-1],1,function(b){
# Calculate discrepancy measure
resid <- blimfit$y-blimfit$X%*%b
# For Durbin-Watson autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals: ks.test
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
# Calculate the replicated discrepancy measure for each column of the trace
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residual: ks.test
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
# PPP is how often the observed D is smaller than replicated D
PPPDW <- mean(obsD[1,] < repD[1,])
PPPNM <- mean(obsD[2,] < repD[2,])
out <- list()
if (any(toupper(type)=="DW")) out$DW <- PPPDW
if (any(toupper(type)=="NORM")) out$Normality <- PPPNM
return(out)
}
PPC(fit1,type = "NORM")
warnings()
PPC <- function(blimfit, fast = TRUE, type = "DW"){
# Check if object has class blimfit
if (class(blimfit) != "blimfit") stop("Please enter a blimfit object!")
# Remove unnecessary information from the posterior distributions (the
# R-squared column)
if (fast == F){
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n")
} else {
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n")
}
# Calculate the observed discrepancy measure for each column of the trace
obsD <- apply(trace[,-1],1,function(b){
# Calculate discrepancy measure
resid <- blimfit$y-blimfit$X%*%b
# For Durbin-Watson autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# Calculate the replicated discrepancy measure for each column of the trace
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residual: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# PPP is how often the observed D is smaller than replicated D
PPPDW <- mean(obsD[1,] < repD[1,])
PPPNM <- mean(obsD[2,] < repD[2,])
out <- list()
if (any(toupper(type)=="DW")) out$DW <- PPPDW
if (any(toupper(type)=="NORM")) out$Normality <- PPPNM
return(out)
}
warnings()
PPC(fit1,type = "NORM")
PPC(fit1,type = c("DW","NORM"))
PPC(fit1,type = c("DW","NORM"))
PPC(fit1,type = c("DW","NORM"))
PPC(fit1,type = c("DW","NORM"))
PPC(fit1,type = c("DW","NORM"))
PPC <- function(blimfit, fast = TRUE, type = "norm"){
# POSSIBLE TYPES
# norm : a PPC for normality of residuals using ks.test
# dw : a PPC for autocorrelation of residuals using durbin-watson statistic
# Check if object has class blimfit
if (class(blimfit) != "blimfit") stop("Please enter a blimfit object!")
# Remove unnecessary information from the posterior distributions (the
# R-squared column)
if (fast == F){
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n")
} else {
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n")
}
# Calculate the observed discrepancy measure for each row of the trace
obsD <- apply(trace[,-1],1,function(b){
# Calculate discrepancy measure
resid <- blimfit$y-blimfit$X%*%b
# For Durbin-Watson autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# Calculate the replicated discrepancy measure for each row of the trace
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residual: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# PPP is how often the observed D is smaller than replicated D
PPPDW <- mean(obsD[1,] < repD[1,])
PPPNM <- mean(obsD[2,] < repD[2,])
out <- list()
if (any(toupper(type)=="DW")) out$ResidualAutocorrelation <- PPPDW
if (any(toupper(type)=="NORM")) out$ResidualNormality <- PPPNM
return(out)
}
PPC(fit1,type = c("DW","NORM"))
PPC <- function(blimfit, fast = TRUE, type = "norm"){
# POSSIBLE TYPES
# norm : a PPC for normality of residuals using ks.test
# dw : a PPC for autocorrelation of residuals using durbin-watson statistic
# Check if object has class blimfit
if (class(blimfit) != "blimfit") stop("Please enter a blimfit object!")
# Remove unnecessary information from the posterior distributions (the
# R-squared column)
if (fast == F){
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n\n")
} else {
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n\n")
}
# Calculate the observed discrepancy measure for each row of the trace
obsD <- apply(trace[,-1],1,function(b){
# Calculate discrepancy measure
resid <- blimfit$y-blimfit$X%*%b
# For Durbin-Watson autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# Calculate the replicated discrepancy measure for each row of the trace
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residual: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# PPP is how often the observed D is smaller than replicated D
PPPDW <- mean(obsD[1,] < repD[1,])
PPPNM <- mean(obsD[2,] < repD[2,])
out <- list()
if (any(toupper(type)=="DW")) out$ResidualAutocorrelation <- PPPDW
if (any(toupper(type)=="NORM")) out$ResidualNormality <- PPPNM
return(out)
}
PPC(fit1,type = c("DW","NORM"))
?ks.test
rm(list = ls())
