# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
repD
length(repD)
ncol(repD)
nrow(repD)
out <- list()
length(out)
PPPDW <- 0.00123144
if (any(toupper(type)=="DW")) out$DW <- PPPDW
out
PPC <- function(blimfit, fast = TRUE, type = "DW"){
# Check if object has class blimfit
if (class(blimfit) != "blimfit") stop("Please enter a blimfit object!")
# Remove unnecessary information from the posterior distributions (the
# R-squared column)
if (fast == F){
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n")
} else {
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n")
}
# Calculate the observed discrepancy measure for each column of the trace
obsD <- apply(trace[,-1],1,function(b){
# Calculate discrepancy measure
resid <- blimfit$y-blimfit$X%*%b
# For Durbin-Watson autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals: ks.test
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
# Calculate the replicated discrepancy measure for each column of the trace
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residual: ks.test
Dnm <- ks.test(resid,pnorm)$statistic
return(c(Ddw,Dnm))
})
# PPP is how often the observed D is smaller than replicated D
PPPDW <- mean(obsD[1,] < repD[1,])
PPPNM <- mean(obsD[2,] < repD[2,])
out <- list()
if (any(toupper(type)=="DW")) out$DW <- PPPDW
if (any(toupper(type)=="NORM")) out$Normality <- PPPNM
return(out)
}
PPC(fit1,type = "NORM")
warnings()
PPC <- function(blimfit, fast = TRUE, type = "DW"){
# Check if object has class blimfit
if (class(blimfit) != "blimfit") stop("Please enter a blimfit object!")
# Remove unnecessary information from the posterior distributions (the
# R-squared column)
if (fast == F){
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n")
} else {
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n")
}
# Calculate the observed discrepancy measure for each column of the trace
obsD <- apply(trace[,-1],1,function(b){
# Calculate discrepancy measure
resid <- blimfit$y-blimfit$X%*%b
# For Durbin-Watson autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# Calculate the replicated discrepancy measure for each column of the trace
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residual: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# PPP is how often the observed D is smaller than replicated D
PPPDW <- mean(obsD[1,] < repD[1,])
PPPNM <- mean(obsD[2,] < repD[2,])
out <- list()
if (any(toupper(type)=="DW")) out$DW <- PPPDW
if (any(toupper(type)=="NORM")) out$Normality <- PPPNM
return(out)
}
warnings()
PPC(fit1,type = "NORM")
PPC(fit1,type = c("DW","NORM"))
PPC(fit1,type = c("DW","NORM"))
PPC(fit1,type = c("DW","NORM"))
PPC(fit1,type = c("DW","NORM"))
PPC(fit1,type = c("DW","NORM"))
PPC <- function(blimfit, fast = TRUE, type = "norm"){
# POSSIBLE TYPES
# norm : a PPC for normality of residuals using ks.test
# dw : a PPC for autocorrelation of residuals using durbin-watson statistic
# Check if object has class blimfit
if (class(blimfit) != "blimfit") stop("Please enter a blimfit object!")
# Remove unnecessary information from the posterior distributions (the
# R-squared column)
if (fast == F){
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n")
} else {
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n")
}
# Calculate the observed discrepancy measure for each row of the trace
obsD <- apply(trace[,-1],1,function(b){
# Calculate discrepancy measure
resid <- blimfit$y-blimfit$X%*%b
# For Durbin-Watson autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# Calculate the replicated discrepancy measure for each row of the trace
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residual: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# PPP is how often the observed D is smaller than replicated D
PPPDW <- mean(obsD[1,] < repD[1,])
PPPNM <- mean(obsD[2,] < repD[2,])
out <- list()
if (any(toupper(type)=="DW")) out$ResidualAutocorrelation <- PPPDW
if (any(toupper(type)=="NORM")) out$ResidualNormality <- PPPNM
return(out)
}
PPC(fit1,type = c("DW","NORM"))
PPC <- function(blimfit, fast = TRUE, type = "norm"){
# POSSIBLE TYPES
# norm : a PPC for normality of residuals using ks.test
# dw : a PPC for autocorrelation of residuals using durbin-watson statistic
# Check if object has class blimfit
if (class(blimfit) != "blimfit") stop("Please enter a blimfit object!")
# Remove unnecessary information from the posterior distributions (the
# R-squared column)
if (fast == F){
trace <- blimfit$trace[,-c(ncol(blimfit$trace))]
cat("Precise PPP calculation. This might take a while! \n\n")
} else {
trace <- blimfit$trace[sample(nrow(blimfit$trace),1000),
-c(ncol(blimfit$trace))]
cat("Fast PPP calculation. Only 1000 iterations evaluated.
Turn off the option 'fast' to perform a precise PPP calculation. \n\n")
}
# Calculate the observed discrepancy measure for each row of the trace
obsD <- apply(trace[,-1],1,function(b){
# Calculate discrepancy measure
resid <- blimfit$y-blimfit$X%*%b
# For Durbin-Watson autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residuals: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# Calculate the replicated discrepancy measure for each row of the trace
repD <- apply(trace,1,function(trace){
# Assign proper parameters
var <- trace[1]
b <- trace[-1]
# Generate data under model
y <- apply(blimfit$X%*%b,1,function(mean){rnorm(1,mean,sqrt(var))})
# Calculate discrepancy measure
resid <- y-blimfit$X%*%b
# For Durbin-Watson Autocorrelation test
auto <- resid[-1]-resid[-length(resid)]
DW <- (t(auto)%*%auto)/(t(resid)%*%resid)
Ddw <- abs(DW-2)
# For normality of residual: ks.test
Dnm <- suppressWarnings(ks.test(resid,pnorm)$statistic)
return(c(Ddw,Dnm))
})
# PPP is how often the observed D is smaller than replicated D
PPPDW <- mean(obsD[1,] < repD[1,])
PPPNM <- mean(obsD[2,] < repD[2,])
out <- list()
if (any(toupper(type)=="DW")) out$ResidualAutocorrelation <- PPPDW
if (any(toupper(type)=="NORM")) out$ResidualNormality <- PPPNM
return(out)
}
PPC(fit1,type = c("DW","NORM"))
?ks.test
rm(list = ls())
setwd("~/1 - Studie/3 - UU/Semester 2/Bayesian Statistics/Assignment_2/handin")
library(devtools) # Required for installation
install_github("vankesteren/blim") # Install my package from github
library(blim) # Load this package
fit <- blim(dist~speed, data=cars)
fit2 <- blim(formula = dist~speed, data = cars, # normal lm syntax
iter = 50000, burnin = 2000, # iterations and burnin
inits = list(var = 200, b0 = -15, b1 = 3), # inits
thin = 0, # thinning (final trace = (iter-burnin)/thin)
prior_tau = "dgamma(0.001,0.001)", # tau prior (dgamma only!)
prior_b = c("dcauchy(0,2000)", # nonconjug. prior for intercept b0
"dunif(3,4.5)"), # nonconjugate prior for slope b1
method = "rmhs", # method: rbr, cppbr, rgs or rmhs
mtsprior = F, # Calculate Minimum Training Sample priors?
verbose = T, # Display information yes/no
dtuning = 1000) # Dynamic Tuning each x rmhs iterations.
BF(fit2,fit)
BF(fit2,fit)
BF(fit2,fit, bootstrap = T, plot = T)
birthwt$nothing <- with(birthwt,floor(1-(ht+smoke)/2))
library(MASS)
birthwt$nothing <- with(birthwt,floor(1-(ht+smoke)/2))
# fit model
bw <- blim(bwt~0+nothing+smoke+ht, data = birthwt, method = "rgs",
mtsprior = T, iter = 1000)
cplots(bw)
aplots(bw)
bw$summary
(BF1 <- BF(bw, model = "par[1] > par[2] && par[2] > par[3]", complement = F))
(BF1 <- ICBF(bw, model = "par[1] > par[2] && par[2] > par[3]", complement = F))
(BF2 <- ICBF(bw, model = "par[1] > par[3] && par[3] > par[2]", complement = F))
bw <- blim(bwt~0+nothing+smoke+ht, data = birthwt, method = "rgs",
mtsprior = T, iter = 10000)
(BF1 <- ICBF(bw, model = "par[1] > par[2] && par[2] > par[3]", complement = F))
(BF2 <- ICBF(bw, model = "par[1] > par[3] && par[3] > par[2]", complement = F))
cat("BF12 is",(BF1/BF2)[3])
bw <- blim(bwt~0+nothing+smoke+ht, data = birthwt, method = "rgs",
mtsprior = T, iter = 100000)
cplots(bw)
mod1 <- blim(bwt~0+nothing+smoke+ht+ui, birthwt, iter = 99999,
mtsprior = T, method = "rmhs", dtuning = T)
cplots(mod1)
cplots(mod1, params = 1:5)
aplots(mod1, params = 1:5)
cplots(mod1, params = 1:5)
mod2 <- blim(bwt~0+nothing+smoke+ht+ui+age, birthwt, iter = 99999,
prior_b = c("dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dcauchy(0,0.7071068)"),
method = "rmhs", dtuning = T)
cplots(mod2)
BF(mod1,mod2)
BF(mod1,mod2)
BF(mod1,mod2, bootstrap = T)
mod2 <- blim(bwt~0+nothing+smoke+ht+ui+scale(age), birthwt, iter = 99999,
prior_b = c("dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dcauchy(0,0.7071068)"),
method = "rmhs", dtuning = T)
mod2 <- blim(bwt~0+nothing+smoke+ht+ui+scale(age), birthwt, iter = 99999,
prior_b = c("dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dcauchy(0,0.7071068)"),
method = "rmhs", dtuning = T)
# Model 2 has one covariate with a cauchy prior
mod2 <- blim(bwt~0+nothing+smoke+ht+ui+scale(age), birthwt, iter = 99999,
prior_b = c("dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dcauchy(0,0.7071068)"),
method = "rmhs", dtuning = 100)
mod1 <- blim(bwt~0+nothing+smoke+ht+ui, birthwt, iter = 99999,
mtsprior = T, method = "rmhs", dtuning = 100)
cplots(mod1, params = 1:5)
aplots(mod1, params = 1:5)
mod3 <- blim(bwt~0+nothing+smoke+ht+ui+scale(age)+scale(lwt), birthwt,
iter = 99999,
prior_b = c("dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dcauchy(0,0.7071068)", "dcauchy(0,0.7071068)"),
method = "rmhs", dtuning = 100)
cplots(mod3, params = 1:7)
aplots(mod3, params = 1:7)
cplots(mod2, params = 1:6)
mod2 <- blim(bwt~0+nothing+smoke+ht+ui+scale(age), data = birthwt, iter = 99999,
prior_b = c("dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dcauchy(0,100)"),
method = "rmhs", dtuning = 100)
cplots(mod2, params = 1:6)
aplots(mod2, params = 1:6)
mod3 <- blim(bwt~0+nothing+smoke+ht+ui+scale(age)+scale(lwt), data = birthwt,
iter = 99999,
prior_b = c("dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dnorm(2950.05505505506,402402.67622733)",
"dcauchy(0,100)", "dcauchy(0,100)"),
method = "rmhs", dtuning = 100)
cplots(mod3, params = 1:7)
aplots(mod3, params = 1:7)
BF(m1, m2)
BF(mod1, mod2)
BF(mod2, mod3)
BF(mod1, mod3)
DIC(mod1)
DIC(mod2)
DIC(mod3)
(BF1 <- ICBF(bw, model = "par[1] > par[2] && par[2] > par[3]", complement = F))
lmml(fit)
ICBF(fit, model = "par[1] < 0") # First parameter (intercept) smaller than 0
cplots(fit) # Convergence
aplots(fit) # Autocorrelation
rm(bw)
rm(BF1)
rm(BF2)
# More complex example using informative nonconjugate priors (rmhs)
fit2 <- blim(formula = dist~speed, data = cars, # normal lm syntax
iter = 50000, burnin = 2000, # iterations and burnin
inits = list(var = 200, b0 = -15, b1 = 3), # inits
thin = 0, # thinning (final trace = (iter-burnin)/thin)
prior_tau = "dgamma(0.001,0.001)", # tau prior (dgamma only!)
prior_b = c("dcauchy(0,2000)", # nonconjug. prior for intercept b0
"dunif(3,4.5)"), # nonconjugate prior for slope b1
method = "rmhs", # method: rbr, cppbr, rgs or rmhs
mtsprior = F, # Calculate Minimum Training Sample priors?
verbose = T, # Display information yes/no
dtuning = 1000) # Dynamic Tuning each x rmhs iterations.
fit2$summary # Note the changed parameter estimates
cplots(fit2)  # Note the truncated b1 distribution
aplots(fit2)  # Check autocorrelation
BF(fit2,fit, bootstrap = T, plot = T)
?birthwt
blim(bwt~0+nothing+smoke+ht, birthwt)
blim(bwt~0+nothing+smoke+ht, birthwt, mtsprior = T)
test <- blim(bwt~0+nothing+smoke+ht, birthwt, mtsprior = T)
test <- blim(bwt~0+nothing+smoke+ht, birthwt, mtsprior = T)
test <- blim(bwt~0+nothing+smoke+ht, birthwt, mtsprior = T)
test <- blim(bwt~0+nothing+smoke+ht, birthwt, mtsprior = T)
test <- blim(bwt~0+nothing+smoke+ht, birthwt, mtsprior = T)
test <- blim(bwt~0+nothing+smoke+ht, birthwt, mtsprior = T)
rm(test)
birthwt$nothing <- with(birthwt,floor(1-(ht+smoke)/2))
mod1 <- blim(bwt~0+nothing+smoke+ht, data = birthwt, iter = 99999,
prior_b = c("dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)"),
method = "rmhs", dtuning = 100)
cplots(mod1, params = 1:4)
# Model 2 has age as a covariate with a cauchy prior
mod2 <- blim(bwt~0+nothing+smoke+ht+scale(age), data = birthwt, iter = 99999,
prior_b = c("dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)",
"dcauchy(0,100)"),
method = "rmhs", dtuning = 100)
cplots(mod2, params = 1:5)
summary(mod2)
summary(mod1)
# Model 3 has two covariates, adding mother's weight
mod3 <- blim(bwt~0+nothing+smoke+ht+scale(age)+scale(lwt), data = birthwt,
iter = 99999,
prior_b = c("dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)",
"dcauchy(0,100)",
"dcauchy(0,100)"),
method = "rmhs", dtuning = 100)
cplots(mod3, params = 1:6)
aplots(mod3, params = 1:6)
BF(mod1, mod2)
BF(mod2, mod3)
BF(mod1, mod3)
DIC(mod1)
DIC(mod2)
DIC(mod3)
summary(mod1)
summary(mod1)[-5,]
summary(mod1)[-5,]
BF(mod1, mod2, bootstrap = T, plot = T)
summary(mod1) # note that in this ANOVA specification, Rsquared misbehaves
PPC(mod1)
PPC(mod1, fast = F, type = "norm")
(BF1 <- ICBF(bw, model = "par[1] > par[2] && par[2] > par[3]", complement = F))
(BF1 <- ICBF(mod1, model = "par[1] > par[2] && par[2] > par[3]", complement = F))
(BF2 <- ICBF(bw, model = "par[1] > par[3] && par[3] > par[2]", complement = F))
(BF2 <- ICBF(mod1, model = "par[1] > par[3] && par[3] > par[2]", complement = F))
cat("BF12 is",(BF1/BF2)[3])
1-BF1
0.0003201633/0.8334250468
cplots(mod1, params = 1:4)
fit <- blim(dist~speed, data=cars)
summary(fit)
cplots(fit) # Convergence
summary(mod1) # note that in this ANOVA model, the regular Rsquared misbehaves
source('~/3 - Personal/R/blim/R/blim.r')
mod1 <- blim(bwt~0+nothing+smoke+ht, data = birthwt,iter = 99999,
prior_b = c("dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)"),
method = "rmhs", dtuning = 100)
cplots(mod1)
cplots(mod1, 1:4)
aplots(mod1, 1:4)
library(blim)
# Most simple example with full functionality
fit1 <- blim(dist~speed, data=cars)
summary(fit1)
# More complex example with nonconjugate priors
fit2 <- blim(formula = dist~speed, data = cars, iter = 9999, burnin = 100,
inits = list(var = 200, b0 = -15, b1 = 3), thin = 0,
prior_tau = "dgamma(0.001,0.001)",
prior_b = c("dcauchy(0,2000)", "dunif(3,4.5)"),
method = "rmhs", dtuning = 1000)
summary(fit2)
cplots(fit2)
aplots(fit2)
BF(fit2, fit1)
PPC(fit2)
ICBF(fit1, model = "par[1] > par[2]", complement = TRUE)
ICBF(fit1, model = "par[1] < par[2]", complement = TRUE)
library(devtools)
install_github("vankesteren/blim")
rm(fit1,fit,fit2)
rm(blim)
library(blim)
example(blim)
DIC(mod1)
DIC(mod1)-DIC(mod2)
BF(mod2,mod1)
mod1 <- blim(bwt~0+no+sm+hy+smhy, data = birthwt,iter = 99999,
prior_b = c("dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)"),
method = "rmhs", dtuning = 100)
birthwt$no <- with(birthwt,floor(1-(ht+smoke)/2))
birthwt$sm <- as.numeric(with(birthwt, apply(cbind(birthwt$smoke,birthwt$ht),1,
function(x)x[1]&!x[2])))
birthwt$hy <- as.numeric(with(birthwt, apply(cbind(birthwt$smoke,birthwt$ht),1,
function(x)!x[1]&x[2])))
birthwt$smhy <- as.numeric(with(birthwt,apply(cbind(birthwt$smoke,birthwt$ht),1,
function(x)x[1]&x[2])))
mod1 <- blim(bwt~0+no+sm+hy+smhy, data = birthwt,iter = 99999,
prior_b = c("dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)"),
method = "rmhs", dtuning = 100)
mod2 <- blim(bwt~0+no+sm+hy+smhy+scale(lwt), data = birthwt, iter = 99999,
prior_b = c("dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)",
"dnorm(2950,402403)",
"dcauchy(0,100)"),
method = "rmhs", dtuning = 100)
DIC(mod1)-DIC(mod2)
